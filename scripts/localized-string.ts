import { resolve as pathResolve } from "path";
import fs from "fs";
import { load as yamlLoad, dump as yamlDump } from "js-yaml";

const supportedLanguages = ["en", "zh-cn"];

const defaultLanguage = "en";

const localeDir = pathResolve(__dirname, "..", "i18n-strings");
const staticDir = pathResolve(__dirname, "..", "src", "assets", "locales");
const featureDir = pathResolve(__dirname, "..", "src", "Features", "LocalizedString");

interface ILocalizedString {
    name: string;
    value: string;
    description: string;
    raw?: string;
}

type IStringIdMap = Record<string, number>;

main();

function main() {
    const rawStrings = getRawStrings();
    const idMap = generateLocalizedStringId(rawStrings);
    const enumContent = generateEnums(rawStrings, idMap);
    const typeContent = generateTypes(rawStrings, idMap);

    for (const lang of supportedLanguages) {
        const localizedStrings = getLocalizedString(lang);
        const strings = convertRawToLocalizedString(rawStrings, localizedStrings, lang);
        writeLocale(lang, strings, idMap);
        setLocalizedString(lang, strings);
    }
    writeFeature(typeContent, enumContent);
}

function generateTypes(localizedStrings: ILocalizedString[], idMap: IStringIdMap): string {
    let content = "";
    content += '// This file is auto-generated by "yarn i18n"\n';
    content += "// Do NOT modify this file directly.\n\n";

    // Generate localized string interface, map id to value
    content += "interface ILocalizedStrings {\n";
    for (const localizedString of localizedStrings) {
        const id = idMap[localizedString.name];
        content += `0x${id.toString(16)}: ${JSON.stringify(localizedString.value ?? "BAD STRING")};\n`;
    }
    content += "}\n";

    return content;
}

function generateEnums(localizedStrings: ILocalizedString[], idMap: IStringIdMap): string {
    let content = "";
    content += '// This file is auto-generated by "yarn i18n"\n';
    content += "// Do NOT modify this file directly.\n\n";

    // Generate locale enum, map localized string name to id
    content += "// eslint-disable-next-line @typescript-eslint/naming-convention\n";
    content += "export const enum __LocaleAutoGenerated {\n";
    for (const localizedString of localizedStrings) {
        const id = idMap[localizedString.name];
        content += `/**  
        * Value: ${localizedString.value ?? "BAD STRING"}; 
        * Description: ${localizedString.description};
        */\n`;
        content += `${localizedString.name}=0x${id.toString(16)},\n\n`;
    }
    content += "}\n\n";
    content += "export default __LocaleAutoGenerated;\n";

    return content;
}

function generateLocalizedStringId(localizedStrings: ILocalizedString[]): IStringIdMap {
    const result: IStringIdMap = {};
    localizedStrings.forEach((localizedString) => {
        result[localizedString.name] = cyrb53(localizedString.name);
    });
    return result;
}

function getLocalizedString(lang: string): ILocalizedString[] {
    const filePath = pathResolve(localeDir, `localized-strings.${lang}.yaml`);
    if (!fs.existsSync(filePath)) {
        return [];
    }

    return yamlLoad(fs.readFileSync(filePath, "utf-8")) as ILocalizedString[];
}

function setLocalizedString(lang: string, strings: ILocalizedString[]) {
    const filePath = pathResolve(localeDir, `localized-strings.${lang}.yaml`);
    fs.writeFileSync(filePath, yamlDump(strings).replace(/\n\-/g, "\n\n-"));
}

function getRawStrings(): ILocalizedString[] {
    const rawStringFilePath = pathResolve(localeDir, "raw-strings.yaml");
    return yamlLoad(fs.readFileSync(rawStringFilePath, "utf-8")) as ILocalizedString[];
}

function writeFeature(typeContent: string, enumContent: string) {
    fs.mkdirSync(featureDir, { recursive: true });
    const typePath = pathResolve(featureDir, "locale.d.ts");
    fs.writeFileSync(typePath, typeContent);
    const enumPath = pathResolve(featureDir, "locale.strings.ts");
    fs.writeFileSync(enumPath, enumContent);
}

function writeLocale(lang: string, strings: ILocalizedString[], idMap: IStringIdMap) {
    fs.mkdirSync(staticDir, { recursive: true });
    const filePath = pathResolve(staticDir, `strings.${lang}.json`);
    const content = strings.reduce<Record<number, string>>(
        (pre, cur) => ({
            ...pre,
            [idMap[cur.name]]: cur.value ?? cur.raw ?? "BAD STRING",
        }),
        {},
    );
    fs.writeFileSync(filePath, JSON.stringify(content));
}

function convertRawToLocalizedString(
    rawStrings: ILocalizedString[],
    localizedString: ILocalizedString[],
    lang: string,
): ILocalizedString[] {
    return rawStrings.map((rawString) => {
        if (lang === defaultLanguage) {
            return {
                name: rawString.name,
                value: rawString.value,
                description: rawString.description,
                raw: rawString.value ?? "BAD STRING",
            };
        }

        const localized = localizedString.find((ls) => ls.name === rawString.name);
        return {
            name: rawString.name,
            value: localized && localized.raw === rawString.value ? localized.value : null,
            description: rawString.description,
            raw: rawString.value ?? "BAD STRING",
        };
    });
}

function cyrb53(str: string, seed = 0): number {
    let h1 = 0xdeadbeef ^ seed,
        h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch: number; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
    h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
    h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);

    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
}
